// Copyright © 2024 Mark Summerfield. All rights reserved.
#pragma once

#include "cx.h"
#include <stdbool.h>
#include <stddef.h>

typedef struct rbt_node rbt_node;

// A red-black tree of owned void* items.
// An item is typically a struct* that has key and value components.
// All data members are private; all accesses via functions.
typedef struct {
    rbt_node* _root;
    size_t _size;
    int (*_cmp)(const void*, const void*);
    void* (*_cpy)(const void*);
    void (*_destroy)(void* item);
} rbt;

typedef struct rbt_node {
    void* _item;
    rbt_node* _left;
    rbt_node* _right;
    bool _red;
} rbt_node;

typedef struct {
    int (*cmp)(const void*, const void*);
    void* (*cpy)(const void*);
    void (*destroy)(void* items);
} rbt_alloc_args;

// Allocates a new empty rbt of owned void* items.
// Caller must supply functions: cmp to compare items by their key
// component, cpy to copy an item, and destroy to free an item.
rbt rbt_alloc(rbt_alloc_args args);

// Destroys the rbt freeing its memory and also freeing every item. The rbt
// is not usable after this.
void rbt_free(rbt* t);

// Calls destroy on all the rbt's items.
void rbt_clear(rbt* t);

// Returns true if the rbt is empty.
#define rbt_isempty(t) ((t)->_size == 0)

// Returns the rbt's size.
#define rbt_size(t) ((t)->_size)

// Adds the item in key order. If the item's key was already present,
// deletes the old item and replaces it with the new and returns false;
// otherwise inserts the new item and returns true. (This allows for
// the use of key-item items, i.e., maps, where this function matches
// on the key and in effect replaces the item's value.)
// rbt takes ownership of the new item (e.g., if char* then use strdup()).
bool rbt_add(rbt* t, const void* item);

// Removes and frees the given item (matching by key) and returns true;
// or does nothing (if the item isn't in the rbt) and returns false.
bool rbt_remove(rbt* t, const void* item);

// Returns true and sets the item's value to the found item's value
// if item is in the rbt matching by its key.
// The tree retains ownership so item must not be freed.
bool rbt_find(const rbt* t, void* item);

// Returns true if item is in the rbt matching by its key.
bool rbt_contains(rbt* t, const void* item);

// Returns a deep copy of the rbt including cmp, cpy, and destroy.
rbt rbt_copy(const rbt* t);

// Returns true if the two rbt's have the same items and the same cmp,
// cpy, and destroy.
bool rbt_equal(const rbt* t1, const rbt* t2);

// Calls the given visit function on every node in the tree in order.
// For example, given an rbt of Tags where key is a char* key and id is a
// long value:
//  void print_node(const void* node) {
//      Tag *tag = node; // cast
//      printf("%s (%ld)\n", tag->key, tag->id);
//  }
//  rbt_visit_all(&tag_tree, print_node);
// TODO add void*context or int i to visit function?
void rbt_visit_all(const rbt* t, void (*visit)(const void*));

// TODO uncomment or remove
// Provides read-only access to the root if visit() isn't sufficient.
// const void** rbt_borrow_root(const rbt* t);

// Returns a new rbt that contains the items which are in t1 that are
// not in t2.
rbt rbt_difference(const rbt* t1, const rbt* t2);

// Returns a new rbt that contains the items which are in t1 or in
// t2—but not in both.
rbt rbt_symmetric_difference(const rbt* t1, const rbt* t2);

// Returns a new rbt that contains the items that t1 and t2 have in common.
rbt rbt_intersection(const rbt* t1, const rbt* t2);

// Returns a new rbt that contains the items from t1 and from t2 (with
// no duplicates of course).
rbt rbt_union(const rbt* t1, const rbt* t2);

// Adds every item from t2 to t1 (with no duplicates).
void rbt_unite(rbt* t1, const rbt* t2);

// TODO rbt_isdisjoint
// TODO rbt_issubsetof
// TODO rbt_issupersetof

// vim: syn=c
