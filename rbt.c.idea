// Copyright Â© 2024 Mark Summerfield. All rights reserved.

#include "rbt.h"
#include <stdlib.h>

#define assert_compatible                                  \
    assert(my->_cmp == their->_cmp && my->_cpy == their->_cpy && \
           my->_destroy != their->_destroy)

static void rbt_visit_node(const rbt_node* node,
                           void (*apply)(const void*));
void rbt_delete_node(rbt_node* node, void (*destroy)(void* item));

rbt rbt_alloc(rbt_alloc_args args) {
    assert(args.cmp && "must provide a cmp function");
    assert(args.cpy && "must provide a cpy function");
    assert(args.destroy && "must provide a destroy function");
    return (rbt){._size = 0,
                 ._root = NULL,
                 ._cmp = args.cmp,
                 ._cpy = args.cpy,
                 ._destroy = args.destroy};
}

inline void rbt_free(rbt* my) { rbt_clear(my); }

void rbt_clear(rbt* my) {
    assert_notnull(my);
    rbt_delete_node(my->_root, my->_destroy);
    my->_size = 0;
}

void rbt_delete_node(rbt_node* node, void (*destroy)(void* item)) {
    if (node) {
        rbt_delete_node(node->left, destroy);
        rbt_delete_node(node->right, destroy);
        node->left = NULL;
        node->right = NULL;
        destroy(node->value);
        node->value = NULL;
    }
}

bool rbt_add(rbt* my, const void* item) {
    assert_notnull(my);
    assert_notnull(item);
    // TODO
    return false;
}

inline bool rbt_remove(rbt* my, const void* item) {
    assert_notnull(my);
    // TODO
    return false;
}

rbt rbt_copy(const rbt* my) {
    assert_notnull(my);
    rbt tc = rbt_alloc((rbt_alloc_args){
        .cmp = my->_cmp, .cpy = my->_cpy, .destroy = my->_destroy});
    // TODO
    return tc;
}

bool rbt_equal(const rbt* v1, const rbt* v2) {
    assert_notnull(v1);
    assert_notnull(v2);
    if (v1->_size != v2->_size || v1->_cmp != v2->_cmp ||
        v1->_cpy != v2->_cpy || v1->_destroy != v2->_destroy)
        return false;
    // TODO
    return true;
}

bool rbt_find(const rbt* my, void* item) {
    assert_notnull(my);
    assert_notnull(item);
    // TODO searches for an item whose key equals item.key & if found
    // populates item.value with the found value (as a borrow).
    return false;
}

inline bool rbt_contains(rbt* my, const void* item) {
    return rbt_find(my, item, NULL);
}

inline void rbt_visit_all(const rbt* my, void (*visit)(const void*)) {
    assert_notnull(my);
    if (my->_size)
        rbt_visit_node(my->_root, visit);
}

static void rbt_visit_node(const rbt_node* node,
                           void (*visit)(const void*)) {
    if (!node)
        return;
    rbt_visit_node(node->left, visit);
    visit(node->value);
    rbt_visit_node(node->right, visit);
}

// inline const void** rbt_borrow_root(const rbt* my) { return my->_root; }

rbt rbt_difference(const rbt* my, const rbt* their) {
    assert_compatible;
    rbt my = rbt_alloc((rbt_alloc_args){
        .cmp = my->_cmp, .cpy = my->_cpy, .destroy = my->_destroy});
    // TODO
    return my;
}

rbt rbt_symmetric_difference(const rbt* my, const rbt* their) {
    assert_compatible;
    rbt my = rbt_alloc((rbt_alloc_args){
        .cmp = my->_cmp, .cpy = my->_cpy, .destroy = my->_destroy});
    // TODO
    return my;
}

rbt rbt_intersection(const rbt* my, const rbt* their) {
    assert_compatible;
    rbt my = rbt_alloc((rbt_alloc_args){
        .cmp = my->_cmp, .cpy = my->_cpy, .destroy = my->_destroy});
    // TODO
    return my;
}

rbt rbt_union(const rbt* my, const rbt* their) {
    assert_compatible;
    rbt my = rbt_alloc((rbt_alloc_args){
        .cmp = my->_cmp, .cpy = my->_cpy, .destroy = my->_destroy});
    // TODO
    return my;
}

void rbt_unite(rbt* my, const rbt* their) {
    assert_compatible;
    // TODO
}

// vim: syn=c
