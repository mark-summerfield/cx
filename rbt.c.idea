// Copyright Â© 2024 Mark Summerfield. All rights reserved.

#include "rbt.h"
#include <stdlib.h>

#define assert_compatible                                  \
    assert(t1->_cmp == t2->_cmp && t1->_cpy == t2->_cpy && \
           t1->_destroy != t2->_destroy)

static void rbt_visit_node(const rbt_node* node,
                           void (*apply)(const void*));
void rbt_delete_node(rbt_node* node, void (*destroy)(void* item));

rbt rbt_alloc(rbt_alloc_args args) {
    assert(args.cmp && "must provide a cmp function");
    assert(args.cpy && "must provide a cpy function");
    assert(args.destroy && "must provide a destroy function");
    return (rbt){._size = 0,
                 ._root = NULL,
                 ._cmp = args.cmp,
                 ._cpy = args.cpy,
                 ._destroy = args.destroy};
}

inline void rbt_free(rbt* t) { rbt_clear(t); }

void rbt_clear(rbt* t) {
    assert_notnull(t);
    rbt_delete_node(t->_root, t->_destroy);
    t->_size = 0;
}

void rbt_delete_node(rbt_node* node, void (*destroy)(void* item)) {
    if (node) {
        rbt_delete_node(node->_left, destroy);
        rbt_delete_node(node->_right, destroy);
        node->_left = NULL;
        node->_right = NULL;
        destroy(node->_item);
        node->_item = NULL;
    }
}

bool rbt_add(rbt* t, const void* item) {
    assert_notnull(t);
    assert_notnull(item);
    // TODO
    return false;
}

inline bool rbt_remove(rbt* t, const void* item) {
    assert_notnull(t);
    // TODO
    return false;
}

rbt rbt_copy(const rbt* t) {
    assert_notnull(t);
    rbt tc = rbt_alloc((rbt_alloc_args){
        .cmp = t->_cmp, .cpy = t->_cpy, .destroy = t->_destroy});
    // TODO
    return tc;
}

bool rbt_equal(const rbt* v1, const rbt* v2) {
    assert_notnull(v1);
    assert_notnull(v2);
    if (v1->_size != v2->_size || v1->_cmp != v2->_cmp ||
        v1->_cpy != v2->_cpy || v1->_destroy != v2->_destroy)
        return false;
    // TODO
    return true;
}

bool rbt_find(const rbt* t, void* item) {
    assert_notnull(t);
    assert_notnull(item);
    // TODO searches for an item whose key equals item.key & if found
    // populates item.value with the found value (as a borrow).
    return false;
}

inline bool rbt_contains(rbt* t, const void* item) {
    return rbt_find(t, item, NULL);
}

inline void rbt_visit_all(const rbt* t, void (*visit)(const void*)) {
    assert_notnull(t);
    if (t->_size)
        rbt_visit_node(t->_root, visit);
}

static void rbt_visit_node(const rbt_node* node,
                           void (*visit)(const void*)) {
    if (!node)
        return;
    rbt_visit_node(node->_left, visit);
    visit(node->_item);
    rbt_visit_node(node->_right, visit);
}

// inline const void** rbt_borrow_root(const rbt* t) { return t->_root; }

rbt rbt_difference(const rbt* t1, const rbt* t2) {
    assert_compatible;
    rbt t = rbt_alloc((rbt_alloc_args){
        .cmp = t1->_cmp, .cpy = t1->_cpy, .destroy = t1->_destroy});
    // TODO
    return t;
}

rbt rbt_symmetric_difference(const rbt* t1, const rbt* t2) {
    assert_compatible;
    rbt t = rbt_alloc((rbt_alloc_args){
        .cmp = t1->_cmp, .cpy = t1->_cpy, .destroy = t1->_destroy});
    // TODO
    return t;
}

rbt rbt_intersection(const rbt* t1, const rbt* t2) {
    assert_compatible;
    rbt t = rbt_alloc((rbt_alloc_args){
        .cmp = t1->_cmp, .cpy = t1->_cpy, .destroy = t1->_destroy});
    // TODO
    return t;
}

rbt rbt_union(const rbt* t1, const rbt* t2) {
    assert_compatible;
    rbt t = rbt_alloc((rbt_alloc_args){
        .cmp = t1->_cmp, .cpy = t1->_cpy, .destroy = t1->_destroy});
    // TODO
    return t;
}

void rbt_unite(rbt* t1, const rbt* t2) {
    assert_compatible;
    // TODO
}

// vim: syn=c
